Java code To check number is prime

static boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
}

If using math library function is not allowed then

static boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }

        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                return false;
            }
        }
        return true;
    }

If I have to print prime number in certain range  Suppose 0 to n then

static boolean isPrime(int num) {
    if (num <= 1) {
        return false;
    }
    for (int i = 2; i * i <= num; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

System.out.println("Prime numbers from 0 to " + n + ":");
    for (int i = 0; i <= n; i++) {
        if (isPrime(i)) {
            System.out.print(i + " ");
        }
}


Suppose ranges is very large example 2^31 Then don't you think this will be an inefficient approach and it can get TLE.

Yes â€” youâ€™re absolutely correct ðŸ‘
For a very large range (for example up to 2^31),
the approach of checking every number with trial division will be inefficient and will almost certainly lead to TLE (Time Limit Exceeded).

Letâ€™s break this down clearly and then look at the right approach.

Why the previous approach fails for large ranges
Time complexity

Checking one number for primality: O(âˆšn)

Printing primes from 0 to n: O(nâˆšn)

For:

n=231â‰ˆ2.1Ã—109

This means billions of numbers Ã— thousands of checks â†’ impossible in practice.
So your concern is 100% valid.
Correct approach for large ranges

1ï¸âƒ£ Sieve of Eratosthenes (Best practical solution)

Instead of checking each number independently, we mark multiples.

Complexity
Time: O(n log log n)
Space: O(n)

âš ï¸ Limitation:
For n = 2^31, memory required is ~2GB+ â†’ not feasible on normal systems.

When n is extremely large (like 2Â³Â¹)


2ï¸âƒ£ Segmented Sieve (Industry/Competitive Standard)
This is the right algorithm when:
n is very large
You still want all primes in a range

Idea
Generate primes up to âˆšn
Process numbers in small blocks (segments)
Mark non-primes in each segment

Complexity
Time: O(n log log n)
Memory: O(âˆšn + segment size)

âœ… Avoids TLE
âœ… Avoids memory overflow
‚úÖ Rules Specifically for LeetCode (Java-Oriented)

These help you pass edge cases, write optimal code, and explain clearly.

1Ô∏è‚É£ Always reduce k using modulo when working with cycles
k %= n;


Used in:
Rotate array
Circular buffers
Cyclic shifts

Why: Removes unnecessary full cycles and prevents index errors.

2Ô∏è‚É£ Check edge cases early (Guard Clauses)
if (nums == null || nums.length == 0) return;

Used in:
Arrays
Strings
Linked lists

3Ô∏è‚É£ Prefer HashMap / HashSet for O(1) lookups
Map<Integer, Integer> map = new HashMap<>();


Used in:
Two Sum
Frequency counting
Duplicate detection

4Ô∏è‚É£ Use int indices, not wrapper classes
for (int i = 0; i < n; i++)


Avoid:
Integer i

Why: Faster and cleaner.
5Ô∏è‚É£ Declare variables inside loops whenever possible
for (int i = 0; i < n; i++) {
    int complement = target - nums[i];
}

6Ô∏è‚É£ Avoid unnecessary helper data structures
If problem says:
O(1) extra space

Don‚Äôt do:
int[] temp = new int[n];

7Ô∏è‚É£ Use problem constraints to choose data types

int vs long

Watch for overflow
long sum = (long) a + b;

8Ô∏è‚É£ Return immediately when the answer is found
if (map.containsKey(k)) return new int[]{...};


Avoid extra flags or loops.
9Ô∏è‚É£ Don‚Äôt print anything
System.out.println(...)


‚ùå Will fail submission.
üîü Name variables after the problem concept
int complement = target - nums[i];

Better than:
int k


üö´ Top Mistakes Candidates Make on LeetCode
1Ô∏è‚É£ Ignoring constraints
Constraints tell you the expected algorithm

‚ùå Using O(n¬≤) when n = 10‚Åµ

‚úÖ Rule:
n ‚â§ 10‚Åµ ‚Üí O(n) or O(n log n)
n ‚â§ 10¬≥ ‚Üí O(n¬≤) is okay

2Ô∏è‚É£ Not handling edge cases
Common misses:
Empty array

Single element
k > n

Duplicate values
Negative numbers

Always ask:
‚ÄúWhat is the smallest valid input?‚Äù


9Ô∏è‚É£ Forgetting integer overflow
int sum = a + b; // ‚ùå

Use:
long sum = (long) a + b;


‚òï Java-Specific Clean Code Rules (Important for Interviews)

1Ô∏è‚É£ Prefer final when values don‚Äôt change
final int n = nums.length;
Shows intent clearly.

2Ô∏è‚É£ Use enhanced for loop when index is not needed
for (int num : nums) { }

3Ô∏è‚É£ Use Arrays.sort() instead of manual sort
Arrays.sort(nums);
Cleaner and safer.

4Ô∏è‚É£ Avoid unnecessary object creation
‚ùå Bad:
new Integer(x)

‚úÖ Good:
int x

5Ô∏è‚É£ Use correct collection types
Use case	                Collection
Unique elements	            HashSet
Key-value	                HashMap
Ordered	                    TreeMap
Stack behavior              Deque

Avoid:
Stack<Integer> stack = new Stack<>();

Use:
Deque<Integer> stack = new ArrayDeque<>();

6Ô∏è‚É£ Always import what you use
LeetCode supports:
import java.util.*;


Perfectly acceptable.

7Ô∏è‚É£ Avoid deep nesting
Use early returns.

‚ùå Bad:

if (a) {
    if (b) {
        if (c) {
            return true;
        }
    }
}


‚úÖ Good:

if (!a) return false;
if (!b) return false;
return c;

8Ô∏è‚É£ Keep helper methods private
private void reverse(...) { }

9Ô∏è‚É£ Never modify input unless problem allows
Read the problem carefully.

üîü Optimize only after correctness
Correct + readable > clever code.


‚òï Common Java Pitfalls That Cause WA / TLE
1Ô∏è‚É£ Using == instead of .equals()
s1.equals(s2); // ‚úÖ

2Ô∏è‚É£ Using Stack instead of Deque

‚ùå

Stack<Integer> stack = new Stack<>();


‚úÖ

Deque<Integer> stack = new ArrayDeque<>();

3Ô∏è‚É£ Repeated string concatenation in loops

‚ùå

s += ch;


‚úÖ

StringBuilder sb = new StringBuilder();
sb.append(ch);

4Ô∏è‚É£ Forgetting to reduce k
k %= n;

5Ô∏è‚É£ Using recursion without base case

‚Üí StackOverflowError

6Ô∏è‚É£ Using recursion when iteration is required

Causes:

TLE

Stack overflow

7Ô∏è‚É£ Using slow I/O unnecessarily

(Not common in LeetCode, but still)

Avoid:

Scanner

8Ô∏è‚É£ Sorting when not needed

Sorting = O(n log n)
Hashing = O(n)

9Ô∏è‚É£ Modifying loop variable incorrectly
for (int i = 0; i < n; i++) {
    i++; // ‚ùå
}

üîü Not clearing static/global state

Causes wrong answers across test cases.
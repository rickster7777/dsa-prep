WebSockets are a technology used to create a continuous, two-way connection between a client (like a web browser) and a server, 
allowing for real-time communication. This is particularly useful in situations where you want to send updates instantly, like in 
live chats, notifications, online games, or real-time data feeds.

Here’s a quick overview:

Key Features of WebSockets:

Persistent Connection: Unlike HTTP, where each request opens a new connection, WebSockets establish a single, persistent connection 
that remains open, allowing both the client and server to send data anytime.

Low Latency: WebSockets minimize the delay between sending and receiving data, making them ideal for real-time applications.

Bi-Directional Communication: Both the client and server can send messages to each other, in contrast to HTTP where the client must initiate every request.

Efficient: Once the connection is established, WebSockets use less overhead than regular HTTP requests, leading to more efficient communication.


Basic Flow:
Handshake: The connection begins with a handshake from the client to the server, requesting to upgrade from HTTP to WebSocket.

Data Transfer: Once the connection is upgraded, data can flow freely in both directions until either the client or server closes the connection.


Example Use Cases:
Real-time messaging apps: Chat applications like WhatsApp or Facebook Messenger.
Live sports updates: Instantaneous score updates or live event broadcasts.
Online multiplayer games: Real-time interactions between players.
Stock market ticker: Updating stock prices live as they change.

WebSocket Protocol Overview:
The WebSocket protocol is defined in RFC 6455 and provides full-duplex communication channels over a single, long-lived connection. The 
connection is established using an HTTP handshake, after which it is upgraded to a WebSocket connection.

WebSocket Handshake
1. Client Request:

The client (usually a browser) initiates a WebSocket connection by sending an HTTP request with an Upgrade header.

Here's a basic example of a WebSocket connection request:
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13

Sec-WebSocket-Key: A base64-encoded value generated by the client to prove it supports WebSockets.
Sec-WebSocket-Version: The WebSocket version the client supports (the current version is 13).

2. Server Response:

The server responds with a special HTTP 101 status code (Switching Protocols), indicating it has accepted the WebSocket request.

Example server response:
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: dGhlIHNhbXBsZSBub25jZQ==

Sec-WebSocket-Accept: This is the server’s response to the client’s Sec-WebSocket-Key, calculated by hashing the client’s key with a predefined GUID.
WebSocket Frame Structure
Once the WebSocket connection is established, data is transferred in frames. Each WebSocket frame can carry a small or large amount of data, and the data is sent 
in chunks. Here's a breakdown of the frame structure:

Fin (1 bit): Indicates if this is the final fragment of a message.
RSV1, RSV2, RSV3 (1 bit each): Reserved for future extensions, currently not used.
Opcode (4 bits): Specifies the type of data being sent (e.g., 0x1 for text frames, 0x2 for binary frames).
Mask (1 bit): If this bit is set, the payload data is masked, which is required for client-to-server frames.
Payload length (7, 7+16, or 7+64 bits): The length of the payload data in the frame. If the length exceeds a certain threshold, the length field is expanded.
Masking Key (if Mask is set): 4-byte key to mask the payload data.
Payload Data: The actual data being transferred.
WebSocket Message Types
Text Frames: These frames carry UTF-8 encoded text messages. The opcode for text messages is 0x1.
Binary Frames: These carry binary data. The opcode for binary messages is 0x2.
Control Frames: These frames are used for connection management:
Close (opcode 0x8): Indicates the end of the connection.
Ping (opcode 0x9) and Pong (opcode 0xA): Used for keeping the connection alive and checking connectivity.


WebSocket Closing Handshake
When either the client or server decides to close the WebSocket connection, the following steps occur:
One party sends a Close Frame to initiate the connection closure.
The other party acknowledges the closure with a Close Frame in response.
The WebSocket connection is closed, and the TCP connection is terminated.


WebSocket in Practice: Example with Node.js (Server-side)
Here’s an example of how to implement a simple WebSocket server using Node.js and the ws library:

STEP 1:
Install ws:
npm install ws

STEP 2:
websocket server

const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', ws => {
  console.log('New connection established');

  // Send a message to the client
  ws.send('Welcome to the WebSocket server!');

  // Receive messages from the client
  ws.on('message', message => {
    console.log('Received: %s', message);
  });

  // Close the connection
  ws.on('close', () => {
    console.log('Connection closed');
  });
});

console.log('WebSocket server listening on ws://localhost:8080');


STEP 3:
const socket = new WebSocket('ws://localhost:8080');

socket.onopen = function(event) {
  console.log('Connected to WebSocket server');
  socket.send('Hello Server!');
};

socket.onmessage = function(event) {
  console.log('Received from server: ', event.data);
};

socket.onclose = function(event) {
  console.log('Connection closed');
};


WebSocket Security
While WebSockets provide real-time, bi-directional communication, security is an important consideration:

Use WebSocket Secure (WSS): Just like HTTPS is used to encrypt HTTP traffic, WSS encrypts WebSocket communication using SSL/TLS. This prevents eavesdropping, tampering, and man-in-the-middle attacks.
Authentication: It’s crucial to ensure that only authorized clients can open a WebSocket connection. This can be done via tokens, cookies, or other methods like OAuth.
Rate Limiting and IP Blocking: To prevent abuse and ensure the server is not overwhelmed, rate limiting, IP blocking, and other protective measures should be used.
Advantages and Disadvantages of WebSockets
Advantages:

Low Latency: Ideal for real-time applications due to its persistent connection.
Reduced Overhead: No need to re-establish connections for each request as in HTTP.
Efficient: WebSocket messages are lightweight once the connection is established.
Disadvantages:

Limited Browser Support: Some older browsers or network configurations may not support WebSockets.
Firewall and Proxy Issues: Some firewalls or proxies might block WebSocket connections as they don't handle non-HTTP protocols well.
Resource Intensive: A persistent connection consumes server resources, which can be an issue when handling many simultaneous connections.
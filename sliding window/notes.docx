| Type                 | Window Size | Common Tool | Use Case Example                          |
| -------------------- | ----------- | ----------- | ----------------------------------------- |
| Fixed-size window    | Fixed       | None        | Max average subarray                      |
| Variable-size window | Dynamic     | HashSet     | Longest substring without repeating chars |
| Frequency-based      | Dynamic     | HashMap     | Anagrams, character counts                |
| Monotonic window     | Fixed       | Deque       | Sliding window max/min                    |
| Two-pointer simple   | Variable    | None        | Subarray sum, count of subarrays          |

--------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ§© 1. Fixed-Size Sliding Window
âœ… Use when the subarray/window size k is fixed.
ğŸ§  Key idea:
Maintain a window of size k using a single loop.
Keep updating the sum or another measurement as you slide.

ğŸ›  Common Use Cases:
Max/Min/Average sum of subarray of size k

Shortest/Longest subarray of fixed size satisfying a condition
ğŸ’¡ Tools:
No need for sets or maps â€” just pointers (left, right) and variables for tracking.

Problem	Description	LeetCode #
âœ… Maximum Average Subarray I	Max average of subarray of size k	#643
âœ… Sliding Window Maximum	Max in every subarray of size k	#239
Max Consecutive Ones III	Flip at most k 0s to 1	#1004
Longest Subarray of 1's After Deleting One Element	Delete one element to maximize 1's	#1493

--------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ” 2. Variable-Size Sliding Window

âœ… Use when the size of the window is not fixed, but depends on some condition (e.g., sum, distinct characters, etc.).

ğŸ§  Key idea:
Expand the window until the condition is invalid.
Shrink it until the condition is valid again.
Use two pointers (left, right), dynamically adjusting window size.

ğŸ’¡ Tools:
Use HashMap or HashSet if you need to track:
Frequencies
Uniqueness
Specific counts

Problem	Description	LeetCode #
âœ… Longest Substring Without Repeating Characters	Classic window with HashSet	#3
âœ… Longest Repeating Character Replacement	Replace characters to form a block	#424
Minimum Size Subarray Sum	Smallest window with sum â‰¥ target	#209
Maximum Points You Can Obtain from Cards	Window from two sides	#1423

--------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ§® 3. Frequency-Based Window (HashMap)
âœ… Use when you need to count or track frequencies (e.g., matching pattern, anagram, etc.)

ğŸ’¡ Tools:
Use HashMap<Character, Integer> to track frequencies in the current window.
Often used in problems involving strings, anagrams, or pattern matching.

Problem	Description	LeetCode #
âœ… Permutation in String	Check if s2 contains an anagram of s1	#567
âœ… Find All Anagrams in a String	All anagram starting indices	#438
âœ… Minimum Window Substring	Smallest window with all target chars	#76
Contains Duplicate II	Duplicates within k distance	#219

--------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ“‰ 4. Monotonic Queue / Deque
âœ… Use when you need to track max/min within a window efficiently.

ğŸ’¡ Tools:
Use Deque (Double-ended queue) to maintain decreasing/increasing order of elements (indexes usually).

Problem	Description	LeetCode #
âœ… Sliding Window Maximum	Keep max in O(n) time	#239
Sum of Subarray Minimums	Trickier variant with stack/deque	#907
Shortest Subarray with Sum â‰¥ K	Prefix sums + deque	#862

--------------------------------------------------------------------------------------------------------------------------------------------------------
â— 5. Two Pointers / Math-Based Windows
âœ… Use when you're working with sorted arrays or two arrays, or simple numeric conditions like subarray sum.
ğŸ’¡ Tools:
Just two pointers (left, right) and basic math/logic.

Problem	Description	LeetCode #
âœ… Subarray Product Less Than K	Count subarrays with product < k	#713
âœ… Count Number of Nice Subarrays	Count subarrays with exactly k odd numbers	#1248
Longest Subarray with Absolute Diff â‰¤ Limit	Window with limit constraint	#1438
Number of Subarrays With Bounded Maximum	Count valid subarrays within bounds	#795

ğŸ§  Bonus Practice Tips
Pick 2â€“3 problems from each category.

Focus on understanding the condition that causes the window to expand or contract.
Always draw a few examples on paper before coding.
Let me know if you want these organized in a downloadable table or a spreadsheet format!


Yes â€” this is a standard type of sliding window problem, and the 2k + 1 formula is definitely worth remembering. It's commonly used in:

âœ… 1. K-radius subarray averages (like your problem)
In this type of problem:

You need to compute the average (or sum) of a subarray centered at each index.

To do this, you must include k elements to the left and right of the center.

So the total window size is always 2k + 1.

âœ… 2. Sliding window techniques in general
The 2k + 1 idea comes up in multiple standard problems like:

Moving averages

Maximum/minimum in sliding windows

Prefix sum applications

Signal smoothing or noise reduction in data analysis


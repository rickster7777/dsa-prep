1️⃣ Using synchronized + wait()/notify()
How it works:

You have a shared buffer (like a queue).

Producer threads add items to the buffer.

Consumer threads remove items from the buffer.

If the buffer is full, producers wait.

If the buffer is empty, consumers wait.

Use wait() to make a thread wait, and notify() or notifyAll() to wake threads when state changes.

Simple example:
class SharedBuffer {
    private final Queue<Integer> queue = new LinkedList<>();
    private final int capacity = 5;

    public synchronized void produce(int value) throws InterruptedException {
        while (queue.size() == capacity) {
            wait();  // Wait if buffer full
        }
        queue.add(value);
        System.out.println("Produced " + value);
        notifyAll(); // Notify consumers waiting
    }

    public synchronized int consume() throws InterruptedException {
        while (queue.isEmpty()) {
            wait();  // Wait if buffer empty
        }
        int value = queue.poll();
        System.out.println("Consumed " + value);
        notifyAll(); // Notify producers waiting
        return value;
    }
}


wait() pauses the thread releasing the monitor.

notifyAll() wakes waiting threads to check if they can proceed.

2️⃣ Using BlockingQueue (Recommended)

Java provides thread-safe queues in java.util.concurrent:

BlockingQueue interface has methods like put() and take() which handle waiting automatically.

No need for explicit wait()/notify() calls or synchronized.

Simple example with ArrayBlockingQueue:
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

class Producer implements Runnable {
    private BlockingQueue<Integer> queue;

    Producer(BlockingQueue<Integer> q) { this.queue = q; }

    public void run() {
        try {
            int value = 0;
            while (true) {
                queue.put(value);
                System.out.println("Produced " + value);
                value++;
                Thread.sleep(500);
            }
        } catch (InterruptedException e) { }
    }
}

class Consumer implements Runnable {
    private BlockingQueue<Integer> queue;

    Consumer(BlockingQueue<Integer> q) { this.queue = q; }

    public void run() {
        try {
            while (true) {
                int value = queue.take();
                System.out.println("Consumed " + value);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) { }
    }
}

public class Main {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);
        new Thread(new Producer(queue)).start();
        new Thread(new Consumer(queue)).start();
    }
}

| Feature          | `wait/notify`                                           | `BlockingQueue`                   |
| ---------------- | ------------------------------------------------------- | --------------------------------- |
| Complexity       | More manual synchronization                             | Built-in blocking & thread safety |
| Code readability | More verbose                                            | Cleaner & simpler                 |
| Error prone      | Can cause deadlocks/missed notifications if not careful | Less error prone                  |
| Flexibility      | More control over logic                                 | Standard producer-consumer        |
